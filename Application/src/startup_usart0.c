#include "em_cmu.h"
#include "em_usart.h"
#include "usart0.h"

/***************************************************************************//**
 * @brief
 *   Initializes USART0.
 * @note
 *   This function was autogenerated by energyAware Designer.
 ******************************************************************************/
void USART0_setup(void)
{
  USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;

  init.baudrate     = 9600;
  init.oversampling = usartOVS16;
  init.databits     = usartDatabits8;
  init.parity       = usartNoParity;
  init.stopbits     = usartStopbits1;
  init.mvdis        = 0;
  init.prsRxEnable  = 0;

  USART_InitAsync(USART0, &init);
}

/*************************************************************************//**
 * @brief energyAware Designer MCU initialization
 *
 * This code is generated by the energyAware Designer appliction to configure
 * the EFM32LG280F128 for application specific operation. 
 *
 * The generated code is a starting point, which might require adjustment for
 * correct operation. Call this function at early initialization.
 *****************************************************************************/
void eADesigner_Init(void)
{
  /* Using HFRCO at 14MHz as high frequency clock, HFCLK */
  CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFRCO);
  
  /* No low frequency clock source selected */
  
  /* Enable GPIO clock */
  CMU_ClockEnable(cmuClock_GPIO, true);
  
  /* Pin PE11 is configured to Input enabled */
  GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE11_MASK) | GPIO_P_MODEH_MODE11_INPUT;
  
  /* Enable clock for USART0 */
  CMU_ClockEnable(cmuClock_USART0, true);
  /* Custom initialization for USART0 */
  USART0_setup();
  /* Enable signal RX */
  USART0->ROUTE |= USART_ROUTE_RXPEN;
  
}

/******************************************************************************
* @brief  uartSetup function
*
******************************************************************************/
void DMAUart_Initial_IO(void)
{
    /* Enable clock for GPIO module (required for pin configuration) */
    // CMU_ClockEnable(cmuClock_GPIO, true);
    /* Configure GPIO pins */
    GPIO_PinModeSet(DMAUART_TX_PORT,DMAUART_TX_BIT,DMAUART_TX_MODE, 1);
    GPIO_PinModeSet(DMAUART_RX_PORT,DMAUART_RX_BIT,DMAUART_RX_MODE, 1);
    
    /* Prepare struct for initializing UART in asynchronous mode*/
    uartInit.enable       = usartDisable;   /* Don't enable UART upon intialization */
    uartInit.refFreq      = 0;              /* Provide information on reference frequency. When set to 0, the reference frequency is */
    uartInit.baudrate     = 9600;//115200;         /* Baud rate */
    uartInit.oversampling = usartOVS16;     /* Oversampling. Range is 4x, 6x, 8x or 16x */
    uartInit.databits     = usartDatabits8; /* Number of data bits. Range is 4 to 10 */
    uartInit.parity       = usartNoParity;  /* Parity mode */
    uartInit.stopbits     = usartStopbits1; /* Number of stop bits. Range is 0 to 2 */
    //uartInit.mvdis        = false;          /* Disable majority voting */
    //uartInit.prsRxEnable  = false;          /* Enable USART Rx via Peripheral Reflex System */
    //uartInit.prsRxCh      = usartPrsRxCh0;  /* Select PRS channel if enabled */
    
    /* Initialize USART with uartInit struct */
    USART_InitAsync(uart, &uartInit);
    
    /* Prepare UART Rx and Tx interrupts */
    USART_IntClear(uart, _UART_IF_MASK);
    USART_IntEnable(uart, UART_IF_RXDATAV);
    NVIC_ClearPendingIRQ(UART0_RX_IRQn);
    NVIC_ClearPendingIRQ(UART0_TX_IRQn);
    NVIC_EnableIRQ(UART0_RX_IRQn);
    NVIC_EnableIRQ(UART0_TX_IRQn);
    
    
    /* Enable I/O pins at UART1 location #3 */
    uart->ROUTE = UART_ROUTE_RXPEN | UART_ROUTE_TXPEN | UART_ROUTE_LOCATION_LOC3;
    
    /* Enable UART */
    USART_Enable(uart, usartEnable);
    
    
    /* Write welcome message to UART */
    // uartPutData((uint8_t*) welcomeString, welLen);
}